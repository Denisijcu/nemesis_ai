#!/usr/bin/env python3
"""
N√©mesis IA - RSA Vulnerability Demo
Cap√≠tulo 7: El Colapso del RSA

Demuestra c√≥mo RSA funciona y por qu√© es vulnerable a ataques cu√°nticos
"""

import logging
import random
import time
import math
from typing import Tuple, Optional
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class RSAKey:
    """Representa un par de claves RSA"""
    n: int  # M√≥dulo (p * q)
    e: int  # Exponente p√∫blico
    d: Optional[int] = None  # Exponente privado (opcional para clave p√∫blica)
    p: Optional[int] = None  # Factor primo (secreto)
    q: Optional[int] = None  # Factor primo (secreto)
    key_size: int = 0


class RSAVulnerabilityDemo:
    """Demostraci√≥n de vulnerabilidades de RSA ante ataques cu√°nticos"""
    
    def __init__(self):
        """Inicializa el demostrador"""
        logger.info("üîê RSAVulnerabilityDemo inicializado")
    
    def generate_small_rsa_key(self, bits: int = 16) -> RSAKey:
        """
        Genera clave RSA peque√±a (para demostraci√≥n)
        
        Args:
            bits: Tama√±o en bits (usar valores peque√±os para demo)
            
        Returns:
            RSAKey generada
        """
        
        # Generar dos primos peque√±os
        p = self._generate_prime(bits // 2)
        q = self._generate_prime(bits // 2)
        
        # Asegurar que p != q
        while p == q:
            q = self._generate_prime(bits // 2)
        
        # Calcular n = p * q
        n = p * q
        
        # Calcular œÜ(n) = (p-1)(q-1)
        phi = (p - 1) * (q - 1)
        
        # Elegir e (t√≠picamente 65537, pero ajustar para n√∫meros peque√±os)
        e = 65537
        while e >= phi or math.gcd(e, phi) != 1:
            e = random.randrange(3, phi, 2)
        
        # Calcular d (inverso modular de e mod œÜ(n))
        d = self._mod_inverse(e, phi)
        
        key_size = n.bit_length()
        
        return RSAKey(
            n=n,
            e=e,
            d=d,
            p=p,
            q=q,
            key_size=key_size
        )
    
    def encrypt(self, message: int, public_key: RSAKey) -> int:
        """
        Cifra un mensaje con RSA
        
        Args:
            message: Mensaje a cifrar (n√∫mero)
            public_key: Clave p√∫blica RSA
            
        Returns:
            Mensaje cifrado
        """
        
        if message >= public_key.n:
            raise ValueError(f"Mensaje debe ser < {public_key.n}")
        
        # c = m^e mod n
        ciphertext = pow(message, public_key.e, public_key.n)
        
        return ciphertext
    
    def decrypt(self, ciphertext: int, private_key: RSAKey) -> int:
        """
        Descifra un mensaje con RSA
        
        Args:
            ciphertext: Mensaje cifrado
            private_key: Clave privada RSA
            
        Returns:
            Mensaje original
        """
        
        if not private_key.d:
            raise ValueError("Clave privada requerida para descifrar")
        
        # m = c^d mod n
        message = pow(ciphertext, private_key.d, private_key.n)
        
        return message
    
    def factorize_classical(self, n: int, timeout_seconds: float = 5.0) -> Optional[Tuple[int, int]]:
        """
        Intenta factorizar n usando m√©todos cl√°sicos (trial division)
        
        Args:
            n: N√∫mero a factorizar
            timeout_seconds: Tiempo m√°ximo de intento
            
        Returns:
            (p, q) si se factoriza, None si timeout
        """
        
        start_time = time.time()
        
        # Trial division simple
        for i in range(2, int(math.sqrt(n)) + 1):
            # Check timeout
            if time.time() - start_time > timeout_seconds:
                return None
            
            if n % i == 0:
                return (i, n // i)
        
        return None
    
    def simulate_shor_attack(self, n: int) -> Tuple[int, int]:
        """
        SIMULA el algoritmo de Shor (no es implementaci√≥n real)
        
        En realidad, el algoritmo de Shor requiere una computadora cu√°ntica.
        Esto es solo una simulaci√≥n para prop√≥sitos educativos.
        
        Args:
            n: N√∫mero a factorizar (n = p * q)
            
        Returns:
            (p, q) factores primos
        """
        
        logger.info(f"üîÆ Simulando ataque de Shor a n={n}")
        
        # PASO 1: Elegir a aleatorio < n
        a = random.randint(2, n - 1)
        
        logger.info(f"   Paso 1: Eligiendo a={a}")
        
        # PASO 2: Calcular gcd(a, n)
        g = math.gcd(a, n)
        if g != 1:
            logger.info(f"   Paso 2: ¬°Suerte! gcd({a}, {n}) = {g}")
            return (g, n // g)
        
        logger.info(f"   Paso 2: gcd({a}, {n}) = 1")
        
        # PASO 3: Usar computadora cu√°ntica para encontrar periodo r
        # tal que a^r ‚â° 1 (mod n)
        # 
        # EN UNA COMPUTADORA CU√ÅNTICA REAL:
        # - Se crear√≠a superposici√≥n de todos los valores posibles
        # - Se aplicar√≠a transformada cu√°ntica de Fourier
        # - Se medir√≠a para colapsar a un estado que revela r
        #
        # AQU√ç: Simulamos encontrando r por fuerza bruta (¬°trampa!)
        
        logger.info(f"   Paso 3: [SIMULACI√ìN] Usando QFT para encontrar periodo r...")
        
        r = self._find_order(a, n)
        
        logger.info(f"   Periodo encontrado: r={r}")
        
        # PASO 4: Si r es impar o a^(r/2) ‚â° -1 (mod n), reintentar
        if r % 2 != 0:
            logger.info(f"   Paso 4: r es impar, reintentando...")
            return self.simulate_shor_attack(n)
        
        # PASO 5: Calcular factores
        factor1 = math.gcd(a**(r//2) - 1, n)
        factor2 = math.gcd(a**(r//2) + 1, n)
        
        logger.info(f"   Paso 5: Factores calculados")
        
        if factor1 != 1 and factor1 != n:
            p = factor1
            q = n // factor1
            logger.info(f"   ‚úÖ Factorizaci√≥n exitosa: {n} = {p} √ó {q}")
            return (p, q)
        
        if factor2 != 1 and factor2 != n:
            p = factor2
            q = n // factor2
            logger.info(f"   ‚úÖ Factorizaci√≥n exitosa: {n} = {p} √ó {q}")
            return (p, q)
        
        # Si no funcion√≥, reintentar
        logger.info(f"   Reintentando...")
        return self.simulate_shor_attack(n)
    
    def _find_order(self, a: int, n: int) -> int:
        """
        Encuentra el orden de a m√≥dulo n
        (m√≠nimo r tal que a^r ‚â° 1 (mod n))
        
        Esto normalmente se har√≠a en una computadora cu√°ntica.
        Aqu√≠ lo hacemos cl√°sicamente solo para la simulaci√≥n.
        """
        
        r = 1
        current = a % n
        
        while current != 1:
            current = (current * a) % n
            r += 1
            
            # Evitar loops infinitos
            if r > n:
                return 2
        
        return r
    
    def _generate_prime(self, bits: int) -> int:
        """Genera un n√∫mero primo de cierto tama√±o en bits"""
        
        while True:
            # Generar n√∫mero impar aleatorio
            p = random.getrandbits(bits)
            p |= (1 << bits - 1) | 1  # Asegurar que sea de 'bits' bits e impar
            
            if self._is_prime(p):
                return p
    
    def _is_prime(self, n: int, k: int = 5) -> bool:
        """Test de primalidad de Miller-Rabin"""
        
        if n < 2:
            return False
        if n == 2 or n == 3:
            return True
        if n % 2 == 0:
            return False
        
        # Escribir n-1 como 2^r * d
        r, d = 0, n - 1
        while d % 2 == 0:
            r += 1
            d //= 2
        
        # Test de Miller-Rabin k veces
        for _ in range(k):
            a = random.randrange(2, n - 1)
            x = pow(a, d, n)
            
            if x == 1 or x == n - 1:
                continue
            
            for _ in range(r - 1):
                x = pow(x, 2, n)
                if x == n - 1:
                    break
            else:
                return False
        
        return True
    
    def _mod_inverse(self, a: int, m: int) -> int:
        """Calcula inverso modular usando algoritmo extendido de Euclides"""
        
        def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
            if a == 0:
                return b, 0, 1
            gcd, x1, y1 = extended_gcd(b % a, a)
            x = y1 - (b // a) * x1
            y = x1
            return gcd, x, y
        
        gcd, x, _ = extended_gcd(a, m)
        
        if gcd != 1:
            raise ValueError("Inverso modular no existe")
        
        return (x % m + m) % m
    
    def demonstrate_vulnerability(self, key_bits: int = 32) -> dict:
        """
        Demuestra completa de vulnerabilidad RSA
        
        Args:
            key_bits: Tama√±o de clave (usar valores peque√±os para demo)
            
        Returns:
            Diccionario con resultados de la demostraci√≥n
        """
        
        print(f"\n{'='*70}")
        print(f"DEMOSTRACI√ìN DE VULNERABILIDAD RSA ({key_bits} bits)")
        print(f"{'='*70}\n")
        
        # 1. Generar clave RSA
        print("1Ô∏è‚É£  Generando clave RSA...")
        key = self.generate_small_rsa_key(key_bits)
        
        print(f"   ‚úÖ Clave generada:")
        print(f"      p = {key.p}")
        print(f"      q = {key.q}")
        print(f"      n = {key.n} (m√≥dulo p√∫blico)")
        print(f"      e = {key.e} (exponente p√∫blico)")
        print(f"      d = {key.d} (exponente privado - SECRETO)")
        print(f"      Tama√±o: {key.key_size} bits")
        
        # 2. Cifrar mensaje
        print(f"\n2Ô∏è‚É£  Cifrando mensaje secreto...")
        message = 42  # "La respuesta a todo"
        ciphertext = self.encrypt(message, key)
        
        print(f"   Mensaje original:  {message}")
        print(f"   Mensaje cifrado:   {ciphertext}")
        
        # 3. Descifrar (con clave privada)
        print(f"\n3Ô∏è‚É£  Descifrando con clave privada (leg√≠timo)...")
        decrypted = self.decrypt(ciphertext, key)
        print(f"   Mensaje descifrado: {decrypted}")
        print(f"   ‚úÖ {'CORRECTO' if decrypted == message else 'ERROR'}")
        
        # 4. Ataque cl√°sico (factorizaci√≥n por fuerza bruta)
        print(f"\n4Ô∏è‚É£  Ataque CL√ÅSICO (Factorizaci√≥n por fuerza bruta)...")
        print(f"   Intentando factorizar n = {key.n}...")
        
        start_classical = time.time()
        classical_result = self.factorize_classical(key.n, timeout_seconds=5.0)
        classical_time = time.time() - start_classical
        
        if classical_result:
            p_found, q_found = classical_result
            print(f"   ‚úÖ Factorizaci√≥n exitosa en {classical_time:.4f}s")
            print(f"      {key.n} = {p_found} √ó {q_found}")
        else:
            print(f"   ‚ùå Timeout despu√©s de {classical_time:.2f}s")
            print(f"      (Para claves m√°s grandes, esto tomar√≠a a√±os/siglos)")
        
        # 5. Ataque cu√°ntico (Shor)
        print(f"\n5Ô∏è‚É£  Ataque CU√ÅNTICO (Algoritmo de Shor - simulado)...")
        print(f"   Usando computadora cu√°ntica para factorizar n = {key.n}...")
        
        start_quantum = time.time()
        p_quantum, q_quantum = self.simulate_shor_attack(key.n)
        quantum_time = time.time() - start_quantum
        
        print(f"   ‚úÖ Factorizaci√≥n cu√°ntica exitosa en {quantum_time:.4f}s")
        print(f"      {key.n} = {p_quantum} √ó {q_quantum}")
        
        # 6. Recuperar clave privada
        print(f"\n6Ô∏è‚É£  Recuperando clave privada desde factores...")
        phi = (p_quantum - 1) * (q_quantum - 1)
        d_recovered = self._mod_inverse(key.e, phi)
        
        print(f"   œÜ(n) = {phi}")
        print(f"   d recuperada = {d_recovered}")
        print(f"   d original   = {key.d}")
        print(f"   ‚úÖ {'MATCH' if d_recovered == key.d else 'ERROR'}")
        
        # 7. Descifrar mensaje con clave robada
        print(f"\n7Ô∏è‚É£  Descifrando con clave robada...")
        
        stolen_key = RSAKey(n=key.n, e=key.e, d=d_recovered)
        hacked_message = self.decrypt(ciphertext, stolen_key)
        
        print(f"   Mensaje descifrado: {hacked_message}")
        print(f"   üö® RSA COMPROMETIDO: {'S√ç' if hacked_message == message else 'NO'}")
        
        # Resumen
        print(f"\n{'='*70}")
        print(f"üìä RESUMEN:")
        print(f"{'='*70}")
        print(f"   Tama√±o de clave:        {key.key_size} bits")
        print(f"   Tiempo cl√°sico:         {classical_time:.4f}s ({'exitoso' if classical_result else 'timeout'})")
        print(f"   Tiempo cu√°ntico:        {quantum_time:.4f}s (exitoso)")
        print(f"   Speedup cu√°ntico:       {classical_time/quantum_time:.1f}x m√°s r√°pido")
        print(f"\n   ‚ö†Ô∏è  CONCLUSI√ìN:")
        print(f"   RSA es VULNERABLE a computadoras cu√°nticas.")
        print(f"   Algoritmo de Shor puede romper RSA en tiempo polinomial.")
        print(f"   Migraci√≥n a Post-Quantum Cryptography es NECESARIA.")
        print(f"{'='*70}\n")
        
        return {
            "key_size": key.key_size,
            "classical_time": classical_time,
            "classical_success": classical_result is not None,
            "quantum_time": quantum_time,
            "quantum_success": True,
            "speedup": classical_time / quantum_time if classical_result else float('inf'),
            "message_compromised": hacked_message == message
        }


def compare_key_sizes():
    """Compara diferentes tama√±os de clave"""
    
    print("\n" + "="*70)
    print("COMPARACI√ìN DE TAMA√ëOS DE CLAVE RSA")
    print("="*70 + "\n")
    
    demo = RSAVulnerabilityDemo()
    
    key_sizes = [16, 24, 32]  # Bits (peque√±os para demo r√°pida)
    
    results = []
    
    for bits in key_sizes:
        print(f"\n{'‚îÄ'*70}")
        print(f"Probando RSA-{bits} bits")
        print(f"{'‚îÄ'*70}")
        
        result = demo.demonstrate_vulnerability(bits)
        results.append((bits, result))
    
    # Tabla comparativa
    print(f"\n{'='*70}")
    print(f"üìä TABLA COMPARATIVA")
    print(f"{'='*70}\n")
    
    print(f"{'Bits':<8} {'Cl√°sico':<12} {'Cu√°ntico':<12} {'Speedup':<12} {'Comprometido'}")
    print(f"{'-'*70}")
    
    for bits, result in results:
        classical = f"{result['classical_time']:.4f}s" if result['classical_success'] else "TIMEOUT"
        quantum = f"{result['quantum_time']:.4f}s"
        speedup = f"{result['speedup']:.1f}x" if result['speedup'] != float('inf') else "‚àû"
        compromised = "‚úÖ S√ç" if result['message_compromised'] else "‚ùå NO"
        
        print(f"{bits:<8} {classical:<12} {quantum:<12} {speedup:<12} {compromised}")
    
    print(f"\n{'='*70}\n")


def real_world_projection():
    """Proyecci√≥n para claves RSA del mundo real"""
    
    print("\n" + "="*70)
    print("PROYECCI√ìN PARA CLAVES RSA REALES")
    print("="*70 + "\n")
    
    real_world_keys = [
        (1024, "Legacy systems"),
        (2048, "Actual est√°ndar"),
        (3072, "Recomendado hasta 2030"),
        (4096, "Alta seguridad"),
    ]
    
    print("Estimaciones de tiempo para factorizar:\n")
    
    for bits, description in real_world_keys:
        print(f"RSA-{bits} ({description}):")
        
        # Tiempo cl√°sico (estimaci√≥n muy aproximada)
        if bits <= 1024:
            classical_years = 1
        elif bits == 2048:
            classical_years = 300_000_000  # 300 millones de a√±os
        elif bits == 3072:
            classical_years = 10**15  # Cuatrillones de a√±os
        else:
            classical_years = 10**20
        
        # Tiempo cu√°ntico con Shor
        # Complejidad: O(n¬≥) donde n = n√∫mero de bits
        # Con computadora cu√°ntica de ~4000 qubits estables
        quantum_hours = (bits ** 3) / 10**9  # Aproximaci√≥n muy simplificada
        
        print(f"   Cl√°sico:  ~{classical_years:,.0f} a√±os")
        print(f"   Cu√°ntico: ~{quantum_hours:.2f} horas (con QC suficientemente grande)")
        print(f"   üí• Reducci√≥n: {classical_years / (quantum_hours / 8760):.2e}x m√°s r√°pido")
        print()
    
    print("‚ö†Ô∏è  Una computadora cu√°ntica con ~4000 qubits l√≥gicos estables")
    print("   puede romper RSA-2048 en menos de un d√≠a.")
    print()
    print("üéØ Estimaci√≥n: Esta capacidad podr√≠a existir entre 2030-2035")
    print("="*70 + "\n")